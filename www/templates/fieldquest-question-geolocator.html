<link rel="import" href="../fieldquest-question-base.html">

<polymer-element name="fieldquest-question-geolocator" extends="fieldquest-question-base">
<template>

  <style>
    :host {
      padding: 0px;
    }
    
    :host-context(.wide) {
      padding: 0px;
    }
      
    .content {
        padding: 40px 40px;
    }
      
    content.wide {
      padding: 40px 40px 48px;
    }
      
    paper-progress {
      display: block;
      width: 100%;
      padding: 0px;
    }
      
    .hide {
        display: none
    }
      
    .success {
        color: green;
    }

  </style>

  <div>
        <paper-progress class="{{{hide: accuracyAcquired} | tokenList}}" indeterminate></paper-progress>
        <div class="content">
          status: {{status}} <BR/>
          latitude: {{latitude}} <BR/>
          longitude: {{longitude}} <BR/>
          accuracy: <span class="{{{success: accuracyAcquired} | tokenList}}">{{accuracy}}m</span> <BR/>
          accuracy required: {{requiredAccuracy}}m <BR/>
          accuracy acquired: {{accuracyAcquired}} <BR/>
        </div>
  </div>

</template>
<script>
    
    Polymer('fieldquest-question-geolocator', {
        
        geolocator: null,
        enableHighAccuracy: true,
        requiredAccuracy: 50,
        accuracyAcquired: false,
        nextQuestionOnRequiredAccuracyAcquired: false,
        
        created: function() {
            this.status = "pending...";
            geolocator = this;
        },
        
        isAnswered: function() {
            return true;
        },
        
        getDisplayValue: function() {
            return "lat:" + this.latitude + ", long:" + this.longitude;
        },
        
        getValue: function() {
            return {latitude: this.latitude, longitude: this.longitude};
        },
        
        setValue: function(value) {
            if (value.latitude && value.longitude) {
                this.latitude = value.latitude;
                this.longitude = value.longitude;
            } else {
                this.reset();
            }
        },
        
        rendered: function() {
            console.info('in rendered');
            this.getLocation();
        },
        
        getLocation: function() {
            console.info('in getLocation()');
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(this.onSuccess, this.onError, {maximumAge:10000, timeout:60000, enableHighAccuracy: this.enableHighAccuracy});
            } else { 
                this.status = "Geolocation not supported.";
            }
        },
            
        onSuccess: function(position) {
            this.geolocator.latitude = position.coords.latitude;
            this.geolocator.longitude = position.coords.longitude;
            this.geolocator.accuracy = position.coords.accuracy;
            this.geolocator.status = "OK";
            if (this.geolocator.requiredAccuracy < position.coords.accuracy) {
                ///Commented out...otherwise it loops for ever. Needs a terminator...I'll be back
                 this.geolocator.status = "Not accurate enough...retrying";
                 this.geolocator.async(function() {
                      this.getLocation();
                    }, null, 500);
            } else {
                this.geolocator.accuracyAcquired = true;
                this.geolocator.status = "Accuracy Acquired";
                if (this.geolocator.question.nextQuestionOnRequiredAccuracyAcquired) {
                    this.geolocator.fire('question-next');
                }
            }
            
        },

        // onError Callback receives a PositionError object
        onError: function(error) {
            this.geolocator.status = 'code: '    + error.code    + '\n' + 'message: ' + error.message + '\n';
        },
        
        reset: function() {
            this.answer = {};
            this.latitude = 0;
            this.longitude = 0;
            this.accuracyAcquired = false;
        },
        
        initQuestion: function(question) {
            this.requiredAccuracy = (question.requiredAccuracy) ? question.requiredAccuracy : this.requiredAccuracy ;
            this.nextQuestionOnRequiredAccuracyAcquired = (question.nextQuestionOnRequiredAccuracyAcquired) ? question.nextQuestionOnRequiredAccuracyAcquired : this.nextQuestionOnRequiredAccuarcyAcquired;
            this.enableHighAccuracy = (question.enableHighAccuracy) ? question.enableHighAccuracy : this.enableHighAccuracy;
        }

    });
    
</script>
</polymer-element>
